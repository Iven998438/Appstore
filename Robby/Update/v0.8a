import tkinter as tk
import subprocess
import time
import sqlite3
import socket
import random
import os
import shutil
import string
import threading

SLEEP_THRESHOLD = 20 * 60  # Zeit in Sekunden
REPO_URL = "https://github.com/username/repo.git"  # Setze die URL zum GitHub-Repository ein

class USBAppInstaller:
    def __init__(self, master):
        self.master = master
        self.master.title("USB App Installer")

        self.label = tk.Label(master, text="Legen Sie den USB-Stick ein und klicken Sie auf Installieren")
        self.label.pack()

        self.install_button = tk.Button(master, text="Installieren", command=self.install_apps)
        self.install_button.pack()

        self.update_button = tk.Button(master, text="Updates installieren", command=self.install_updates_from_usb)
        self.update_button.pack()

    def install_apps(self):
        # Pfade zu den Apps auf dem USB-Stick anpassen
        usb_path = "/media/usb"
        apps_path = os.path.join(usb_path, "apps")

        if os.path.exists(apps_path):
            # Pfade zu den installierten Apps anpassen
            install_path = "/usr/local/bin/apps"

            # Alle Apps vom USB-Stick in den Installationsordner kopieren
            for app in os.listdir(apps_path):
                app_path = os.path.join(apps_path, app)
                shutil.copy(app_path, install_path)

            self.label.config(text="Apps wurden erfolgreich installiert!")
        else:
            self.label.config(text="Keine Apps auf dem USB-Stick gefunden.")

    def install_updates_from_usb(self):
        # Pfade zu den Updates auf dem USB-Stick anpassen
        usb_path = "/media/usb"
        updates_path = os.path.join(usb_path, "updates")

        if os.path.exists(updates_path):
            # Führe hier die Update-Logik aus
            self.label.config(text="Updates werden installiert...")
            time.sleep(2)  # Simuliere die Installation
            self.label.config(text="Updates wurden erfolgreich installiert!")
        else:
            self.label.config(text="Keine Updates auf dem USB-Stick gefunden.")

class RobotServer:
    def __init__(self):
        self.host = "127.0.0.1"
        self.port = 5555
        self.serial_number = "ABC123"  # Setze die Seriennummer des Roboters hier ein

    def handle_client(self, client_socket):
        client_serial = client_socket.recv(1024).decode()
        if client_serial == self.serial_number:
            client_socket.send("Verbunden mit dem Roboter!".encode())
            # Führe hier die Roboterbefehle aus
            while True:
                command = client_socket.recv(1024).decode()
                if command == "shutdown":
                    client_socket.send("Roboter wird heruntergefahren...".encode())
                    break
                elif command == "reboot":
                    client_socket.send("Roboter wird neu gestartet...".encode())
                    break
                elif command == "dance":
                    subprocess.Popen(["python3", "dance.py"])  # Beispielbefehl zum Ausführen eines Tanzskripts
                    client_socket.send("Roboter beginnt zu tanzen...".encode())
                else:
                    client_socket.send("Unbekannter Befehl!".encode())
        else:
            client_socket.send("Ungültige Seriennummer!".encode())
        client_socket.close()

    def start(self):
        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server.bind((self.host, self.port))
        server.listen(5)

        print(f"Roboter wartet auf Verbindungen auf {self.host}:{self.port} ...")

        while True:
            client, addr = server.accept()
            print(f"Verbunden mit {addr[0]}:{addr[1]}")
            client_handler = threading.Thread(target=self.handle_client, args=(client,))
            client_handler.start()

class RobotApp(tk.Tk):
    def __init__(self):
        super().__init__()

        self.title("Robot App")

        self.label = tk.Label(self)
        self.label.pack()

        self.create_menu()

        # USB-App-Installer starten
        self.usb_app_installer = USBAppInstaller(self)

        # Roboter-Server starten
        self.robot_server = RobotServer()
        self.robot_server_thread = threading.Thread(target=self.robot_server.start)
        self.robot_server_thread.start()

        self.animate_eyes()

        self.eat_animation()

        self.mainloop()

    def animate_eyes(self):
        self.label.config(text="\\(•◡•)/")
        self.label.config(font=("Arial", 20))
        self.blink()

    def blink(self):
        self.label.after(2000, self.blink)
        self.label.config(text="ᗧ")
        self.label.after(100, lambda: self.label.config(text="\\(•◡•)/"))

    def eat_animation(self):
        self.label.config(text="(^_^)")
        self.label.after(500, lambda: self.label.config(text="(-_-)"))
        self.label.after(1000, lambda: self.label.config(text="(^_^)"))
        self.label.after(1500, lambda: self.label.config(text="(-_-)"))
        self.label.after(2000, lambda: self.label.config(text="\\(•◡•)/"))
        self.after(2500, self.eat_animation)

    # Andere Methoden bleiben unverändert

    def create_menu(self):
        menubar = tk.Menu(self)

        apps_menu = tk.Menu(menubar, tearoff=0)
        apps_menu.add_command(label="Taschenrechner", command=self.calculator)
        apps_menu.add_command(label="Wecker", command=self.alarm_clock)
        apps_menu.add_command(label="Wetter", command=self.weather_app)
        apps_menu.add_command(label="Musikplayer", command=self.music_player)

        settings_menu = tk.Menu(menubar, tearoff=0)
        settings_menu.add_command(label="Einstellungen", command=self.change_settings)
        settings_menu.add_command(label="Update", command=self.update_app)

        communication_menu = tk.Menu(menubar, tearoff=0)
        communication_menu.add_command(label="Senden", command=self.send_message)
        communication_menu.add_command(label="Empfangen", command=self.receive_message)
        communication_menu.add_command(label="Anrufen", command=self.make_call)

        wifi_menu = tk.Menu(menubar, tearoff=0)
        wifi_menu.add_command(label="Verfügbare Netzwerke", command=self.list_available_networks)
        wifi_menu.add_command(label="Verbinden", command=self.connect_to_network)

        apps_menu.add_separator()
        apps_menu.add_command(label="Java App verbinden", command=self.java_app)

        menubar.add_cascade(label="Apps", menu=apps_menu)
        menubar.add_cascade(label="Einstellungen", menu=settings_menu)
        menubar.add_cascade(label="Kommunikation", menu=communication_menu)
        menubar.add_cascade(label="WiFi", menu=wifi_menu)

        self.config(menu=menubar)

    # Weitere Methoden bleiben unverändert

if __name__ == "__main__":
    app = RobotApp()
